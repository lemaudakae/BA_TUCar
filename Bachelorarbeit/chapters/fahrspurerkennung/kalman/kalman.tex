\section{Kalman-Filter \dcsecondauthorshort}
\label{sec:fahrspurerkennung_kalman}

\subsection{Überblick} \label{ssec:fahrspurerkennung:kalman-filter:ueberblick}
Auch der folgende Ansatz zur Fahrspurerkennung approximiert den Verlauf der Fahrspur als Polynom 3. Grades. Jedoch wird nicht mehr jede Fahrspurmarkierung einzeln, sondern nur noch die Mittellinie modelliert. Um die seitlichen Fahrbahnmarkierungen zu erhalten, können beliebige Punkte des Polynoms senkrecht zu dessen Verlauf um die Fahrspurbreite verschoben werden.
Das in \ref{sec:grundlagen:kalman-filter} eingeführte Kalman-Filter soll verwendet werden um die Lage der Fahrbahnmarkierungen in konsekutiven Aufnahmen zu verfolgen. Final sollen Punkte aus den in Einzelbildern erkannten Verläufen der Straßenmarkierung entnommen, in die Weltkarte eingetragen und somit für den Regelungsalgorithmus verfügbar gemacht werden.

\subsection{Fahrspurmodell}
Als Repräsentation der Fahrspur im Zustandsraum soll das in \autocite{petersfalkoFPGAbasierteBildverarbeitungspipelineZur2009} vorgeschlagene Modell, welches wiederum eine Vereinfachung von \autocite{risackRobustLaneRecognition} darstellt, verwendet werden.
Wie in \ref{ssec:fahrspurerkennung:kalman-filter:ueberblick} angekündigt, soll die Fahrspur als Polynom 3. Grades \begin{math} \gls{y}^{\gls{lat:LinienKOS}}(\gls{x}^{\gls{lat:LinienKOS}}) \end{math} approximiert werden. Um die \glsdesc{lat:systemmatrix} \gls{lat:systemmatrix} zu vereinfachen und einen sehr anschaulichen \glsdesc{lat:statevector} \gls{lat:statevector} zu erhalten, wird für jenen die 0. bis 3. Ableitung des Polynoms an der Stelle \begin{math} \gls{x}^{\gls{lat:LinienKOS}}=0 \end{math} verwendet. 
\begin{equation}
\label{eq:polylane}
\fnf{\gls{x}^{\gls{lat:LinienKOS}}} = \gls{y}^{\gls{lat:LinienKOS}}(\gls{x}^{\gls{lat:LinienKOS}}) =
\scl{a_0} +
\scl{a_1} \cdot \gls{x}^{\gls{lat:LinienKOS}} +
\scl{a_2} \cdot (\gls{x}^{\gls{lat:LinienKOS}})^2 +
\scl{a_3} \cdot (\gls{x}^{\gls{lat:LinienKOS}})^3
\end{equation}
\begin{equation}
\label{eq:statevectorlane}
\gls{lat:statevector} = 
\begin{pmatrix}
\gls{y}^{\gls{lat:LinienKOS}}(0) \\
\der{(\gls{y}^{\gls{lat:LinienKOS}})}(0) \\
\derII{(\gls{y}^{\gls{lat:LinienKOS}})}(0) \\
\derIII{(\gls{y}^{\gls{lat:LinienKOS}})}(0) \\
\end{pmatrix}
=
\begin{pmatrix}
\scl{a_0} \\
\scl{a_1} \\
2 \cdot \scl{a_2} \\
6 \cdot \scl{a_3} \\
\end{pmatrix}
=
\begin{pmatrix}
\gls{lat:lateraloffset} \\
\gls{gre:yawangle} \\
\gls{lat:curvature} \\
\gls{lat:curvaturechange} \\
\end{pmatrix}
\end{equation}
\begin{equation}
\label{eq:polylanestate}
\gls{y}^{\gls{lat:LinienKOS}}(\gls{x}^{\gls{lat:LinienKOS}}) =
\gls{lat:lateraloffset} +
\gls{gre:yawangle} \cdot \gls{x}^{\gls{lat:LinienKOS}} +
\frac{1}{2} \cdot \gls{lat:curvature} \cdot (\gls{x}^{\gls{lat:LinienKOS}})^2 +
\frac{1}{6} \cdot \gls{lat:curvaturechange} (\cdot \gls{x}^{\gls{lat:LinienKOS}})^3
\end{equation}
 
\subsubsection{Initialisierung} 
\label{sssec:fahrspurerkennung:kalman:fahrspurmodell:initialisierung}
 Die Initialisierung des Fahrspurmodells erfolgt durch das Finden der Mittellinie auf dem unmaskierten Bild wie in Abschnitt \ref{par:maskenbau:initial} oder mittels des Riverflow-Algorithmus für die mittlere Fahrbahnmarkierung, beschrieben in Passage \ref{ssec:fahrspurerkennung:riverflow:mittellinie}. Sind alle der Mittellinie zugehörigen Bildpunkte gefunden, kann eine Transformation derer ins Linienkoordinatensystem \gls{lat:LinienKOS} mit anschließender Regression zum Feststellen der Parameter des Polynoms 3. Grades stattfinden. Mittels \eqref{eq:statevectorlane} lässt sich das gefundene Polynom in den Systemzustand \gls{lat:statevector} überführen.
 
 \begin{figure}[htb]
 	\centering
 	\includegraphics[width=0.75\textwidth]{kalman_iteration_komplett}
 	\caption{Plot einer Iteration des Kalmanfilters}
 	\label{fig:kalman:iteration_komplett}
 \end{figure}
 
\subsection{Messung} \label{ssec:fahrspurerkennung:kalman:messung}
Um eine ausreichende Geschwindigkeit des Kalmanfilters zu gewährleisten, muss die Anzahl der Bildpunkte, welche zur Korrektur des prädizierten Zustands verwendet werden, im Gegensatz zu Abschnitt \ref{sec:maskenbau} vermindert werden. Es wird in Anlehnung an \autocite{risackRobustLaneRecognition} das Bild ab dem Vorverarbeitungsschritt nur in relevanten Bereichen betrachtet.
Hierfür werden Geraden \glqq Scanlines\grqq{} senkrecht zum Polynom des Fahrspurmodells berechnet (gelbe Linien in Abb. \ref{fig:kalman:iteration_komplett}). Mathematisch lässt sich dies, basierend auf den Definitionsgleichungen \eqref{eq:polylane} und \eqref{eq:statevectorlane} des Polynoms \(\fnf{\gls{x}^{\gls{lat:LinienKOS}}}=\gls{y}^{\gls{lat:LinienKOS}}(\gls{x}^{\gls{lat:LinienKOS}})\) und Zustandsvektors sowie den Formeln \eqref{eq:derr_polynom3} und \eqref{eq:maske_verschiebungsvektor} zur Berechnung des zum Polynom senkrechten, normierten Vektors \gls{lat:dv}, wie folgt ausdrücken:
\begin{subequations}
\begin{equation}
\vct{m}(\gls{x}^{\gls{lat:LinienKOS}}) =
\begin{pmatrix}
{\gls{x}^{\gls{lat:LinienKOS}}} 	\\
{\fnf{\gls{x}^{\gls{lat:LinienKOS}}}}	\\
\end{pmatrix}
\end{equation}
\begin{equation}
\label{eq:kalman:scanlinecontinous}
\vct{s}(\gls{x}^{\gls{lat:LinienKOS}},\alpha) =
\vct{m}(\gls{x}^{\gls{lat:LinienKOS}})
  + \alpha \cdot \vct{d}(\gls{x}^{\gls{lat:LinienKOS}})
\qquad \alpha \in \mathbb{R}
\end{equation}
\end{subequations}

Die Länge der Scanlines (Wertebereich von \(\alpha\)) sowie der Abstand der Startpunkte/Mittelpunkte \(\vct{m}(\gls{x}^{\gls{lat:LinienKOS}})\) auf dem Polynom sind als Parameter anzusehen, welche Einfluss auf die \gls{acr:roi} zum Erkennen der Mittellinie sowie die Anzahl der Messwerte haben.

Um mit der konstruierten Scanline Bildpunkte adressieren zu können, wird diese in eine diskrete Koordinatenserie überführt \eqref{eq:kalman:scanlinediscrete}:
\begin{equation}
\label{eq:kalman:scanlinediscrete}
\vct{s}(\gls{x}^{\gls{lat:LinienKOS}},\alpha) =
\vct{m}(\gls{x}^{\gls{lat:LinienKOS}})
  + \alpha \cdot \vct{d}(\gls{x}^{\gls{lat:LinienKOS}})
\qquad \alpha \in \mathbb{Z}
\end{equation}
Anschließend müssen deren Elemente vom Linienkoordinatensystem \gls{lat:LinienKOS} ins Bildkoordinatensystem \gls{lat:BildKOS} transformiert und auf ganzzahlige Werte gerundet werden.
Die durch die Koordinatenserie adressierten Pixel des entzerrten Bildes können nun zur weiteren Verarbeitung in einen Zeilenvektor \vct{l} geschrieben werden. 
 \begin{equation}
 \vct{l} =
 \begin{pmatrix}
 \scl{l_1} & \scl{l_2} & \dots & \scl{l_i} & \dots & \scl{l_n}
 \end{pmatrix}
 \end{equation}
 
Nun wird \vct{l} mit dem aus Passage \ref{sec:bildvorverarbeitung:filterung} bekannten Kantendetektor gefiltert. Von der entstandenen Filterantwort \vct{f} wird das Maximum \mxm{\vct{f}} ermittelt. Ist \mxm{\vct{f}} größer als ein bestimmter Schwellwert, wird der Index \begin{math} i_{max} \end{math} des Maxima in \vct{f} vorgemerkt. Um eine Linie nicht wiederholt zu finden, muss die in \vct{f} verbleibende, durch dieselbe Markierung verursachte Filterantwort entfernt werden \eqref{eq:kalman:scanlines:deletefiltresponse}:
\begin{equation}
\label{eq:kalman:scanlines:deletefiltresponse}
\scl{l_{i_{max}-\text{Linienbreite}/2}} \dots \scl{l_{i_{max}}} 
 \dots  \scl{l_{i_{max}+\text{Linienbreite}/2}} = 0
 \end{equation}
Darauffolgend kann nach weiteren, den festgelegten Grenzwert überschreitenden Maxima in \vct{f} gesucht und wie mit dem ersten \mxm{\vct{f}} verfahren werden.
Wird kein ausreichend großes \mxm{\vct{f}} mehr gefunden, können den gefundenen Indizes \begin{math} i_{max} \end{math} via \eqref{eq:kalman:scanlinediscrete} und einer Rücktransformation vom Bildkoordinatensystem \gls{lat:BildKOS} Punkte \vct{p^{\gls{lat:LinienKOS}}} im Linienkoordinatensystem \gls{lat:LinienKOS} zugeordnet werden, welche zur Korrektur des Systemzustands \gls{lat:statevector} vorgesehen sind.

\subsubsection{Randlinen}
Um auch die zentral in der äußeren Fahrbahnmarkierung liegenden Punkte detektieren zu können, werden die Scanlines der Mittelline um die Fahrspurbreite senkrecht zum Polynom verschoben. Nun kann derselbe Algorithmus wie für die Scanlines der mittleren Fahrbahnmarkierung ausgeführt werden. Die gefundenen Koordinaten müssen letztendlich wieder um die Fahrspurbreite zur Mittellinie hin verschoben werden um problemlos zur Zustandskorrektur des Kalmanfilters nutzbar zu sein.
 
\subsection{Zustandsraumbeschreibung}
Da die Herleitung der diskreten Zustandsraumbeschreibung zum aufgestellten Fahrspurmodell einfacher ist als der Umweg über eine Kontinuierliche, wird dieser Ansatz nun verfolgt.
Die \glsdesc{lat:systemmatrix} \gls{lat:systemmatrix} bildet den momentanen \glsdesc{lat:statevector} \(\gls{lat:statevector}(\scl{k})\) auf den folgenden \glsdesc{lat:statevector} \(\gls{lat:statevector}(\scl{k}+1)\) ab, ohne äußere Einflüsse auf das System zu berücksichtigen. Die Lage der Fahrbahnmarkierungen im nächsten Bild soll also auf Basis des aktuellen Bildes vorhergesagt werden.

\subsubsection{Vereinfachungen}
Der Einfluss des Lenkwinkels wird vernachlässigt, da er bei kurzer Periodendauer der Abtastung \(\scl{T_s} = \frac{1}{\text{Bildrate}}\)\scl{T_s} und kleiner Größe seiner selbst kaum Einfluss auf die Lage der Fahrbahn im Folgebild nimmt. Die Bewegung des Fahrzeugs wird also geradlinig in Richtung der Abszisse des Fahrspurkoordinatensystems \gls{lat:LinienKOS} angenommen. 

\subsubsection{Herleitung der Systemmatrix}
Der zurückgelegte Weg \begin{math} \scl{\Delta\gls{x}}_{\gls{lat:LinienKOS}} \end{math} zwischen zwei Bildaufnahmenpunkten kann direkt aus den Encodern des Fahrzeugs ausgelesen werden. Der Folgezustand  \(\gls{lat:statevector}(\scl{k}+1)\) wird wie folgt berechnet:
\begin{equation}
\label{eq:nextstatemapping}
\hat{\gls{lat:statevector}}(\scl{k}+1) =
\begin{pmatrix}
\gls{y}^{\gls{lat:LinienKOS}\scl{k}}(\scl{\Delta\gls{x}}^{\gls{lat:LinienKOS}}) \\
\der{(\gls{y}^{\gls{lat:LinienKOS}}_{\scl{k}})}(\scl{\Delta\gls{x}}^{\gls{lat:LinienKOS}}) \\
\derII{(\gls{y}^{\gls{lat:LinienKOS}}_{\scl{k}})}(\scl{\Delta\gls{x}}^{\gls{lat:LinienKOS}}) \\
\derIII{(\gls{y}^{\gls{lat:LinienKOS}}_{\scl{k}})}(\scl{\Delta\gls{x}}^{\gls{lat:LinienKOS}}) \\
\end{pmatrix}
\end{equation}

In \autocite{petersfalkoFPGAbasierteBildverarbeitungspipelineZur2009} wird beschrieben, dass sich aufgrund von Nichtlinearität aus \ref{eq:nextstatemapping} keine äquivalente Matrix A aufstellen lässt. Da diese Nichtlinearität jedoch nur in Bezug auf \scl{\Delta\gls{x}} und nicht den \glsdesc{lat:statevector} \gls{lat:statevector} besteht, ist dies trotz dessen möglich. Aus \eqref{eq:polylanestate}, \eqref{eq:nextstatemapping} und der Bewegung des Fahrzeugs entlang der x-Achse des Fahrspurkoordinatensystems \gls{lat:LinienKOS} um \scl{\Delta\gls{x}} folgt:
\begin{equation}
\begin{split}
\label{eq:nextstatemappingmatrix}
\hat{\gls{lat:statevector}}(\scl{k}+1) = &
\begin{pmatrix}
\gls{lat:lateraloffset} +
\gls{gre:yawangle} \cdot \scl{\Delta\gls{x}} +
\frac{1}{2} \cdot \gls{lat:curvature} \cdot (\scl{\Delta\gls{x}})^2 +
\frac{1}{6} \cdot \gls{lat:curvaturechange} \cdot (\scl{\Delta\gls{x}})^3 \\
\gls{gre:yawangle} + \gls{lat:curvature} \cdot \scl{\Delta\gls{x}} +
\frac{1}{2} \cdot \gls{lat:curvaturechange} \cdot (\scl{\Delta\gls{x}})^2 \\
\gls{lat:curvature} + \gls{lat:curvaturechange} \cdot \scl{\Delta\gls{x}} \\
\gls{lat:curvaturechange}
\end{pmatrix} \\
& \begin{pmatrix}
1 &  \scl{\Delta\gls{x}} & \frac{1}{2} \cdot (\scl{\Delta\gls{x}})^2 & 
\frac{1}{6} \cdot (\scl{\Delta\gls{x}})^3 \\
0 & 1 &  \scl{\Delta\gls{x}} & \frac{1}{2} \cdot (\scl{\Delta\gls{x}})^2 \\
0 & 0 & 1 &  \scl{\Delta\gls{x}} \\
0 & 0 & 0 & 1
\end{pmatrix}
\cdot
\begin{pmatrix}
\gls{lat:lateraloffset} \\
\gls{gre:yawangle} \\
\gls{lat:curvature} \\
\gls{lat:curvaturechange} \\
\end{pmatrix} \\
& \gls{lat:systemmatrix}
\cdot
\begin{pmatrix}
\gls{lat:lateraloffset} \\
\gls{gre:yawangle} \\
\gls{lat:curvature} \\
\gls{lat:curvaturechange} \\
\end{pmatrix}
\end{split}
\end{equation}

Die in \autocite{petersfalkoFPGAbasierteBildverarbeitungspipelineZur2009} durch Linearisierung an der Stelle \begin{math} \gls{x}^{\gls{lat:LinienKOS}0} = 0 \end{math} erhaltene Matrix hingegen vereinfacht sich durch \eqref{eq:generallinearization} zu:

\begin{equation}
\label{eq:nextstatemappingmatrixlinear}
\hat{\gls{lat:statevector}}(\scl{k}+1) =
\begin{pmatrix}
\gls{lat:lateraloffset} + \gls{gre:yawangle} \cdot \scl{\Delta\gls{x}} \\
\gls{gre:yawangle} + \gls{lat:curvature} \cdot \scl{\Delta\gls{x}}\\
\gls{lat:curvature} + \gls{lat:curvaturechange} \scl{\Delta\gls{x}} \\
\gls{lat:curvaturechange}
\end{pmatrix}
=
\begin{pmatrix}
1 &  \scl{\Delta\gls{x}} & 0 & 0 \\
0 & 1 &  \scl{\Delta\gls{x}} & 0 \\
0 & 0 & 1 &  \scl{\Delta\gls{x}} \\
0 & 0 & 0 & 1
\end{pmatrix}
\cdot
\begin{pmatrix}
\gls{lat:lateraloffset} \\
\gls{gre:yawangle} \\
\gls{lat:curvature} \\
\gls{lat:curvaturechange} \\
\end{pmatrix}
=
\gls{lat:systemmatrix}
\cdot
\begin{pmatrix}
\gls{lat:lateraloffset} \\
\gls{gre:yawangle} \\
\gls{lat:curvature} \\
\gls{lat:curvaturechange} \\
\end{pmatrix}
\end{equation}

\begin{equation}
\label{eq:generallinearization}
\fnf{\gls{x}^{\gls{lat:LinienKOS}}} \approx \fnf{\gls{x}^{\gls{lat:LinienKOS}0}} + 
%\frac{df}{d\gls{x}}|_{\gls{x}_0} \cdot
\derat{\fnfop}{\gls{x}^{\gls{lat:LinienKOS}0}} \cdot
(\gls{x}-\gls{x}^0)
\end{equation}

Da sich die gefahrene Strecke \begin{math} \scl{\Delta\gls{x}}_{\gls{lat:LinienKOS}} \end{math} zwischen den Aufnahmepunkten zweier Bilder geringfügig ändern kann, muss die \glsdesc{lat:systemmatrix} \gls{lat:systemmatrix} vor jedem Prädikationsschritt neu berechnet werden.

\subsubsection{Eingangsmatrix}
Die \glsdesc{lat:inputmatrix} \gls{lat:inputmatrix} modelliert äußere Einflüsse auf die Entwicklung des Systemzustandes \gls{lat:statevector}. Dies könnten z.B. Änderungen des Lenkwinkels sein. Da letzterer jedoch schon bei der Herleitung der \glsdesc{lat:systemmatrix} \gls{lat:systemmatrix} vernachlässigt wurde, kann \gls{lat:inputmatrix} bei weiteren Untersuchungen unberücksichtigt bleiben.

\subsubsection{Ausgangsmatrix/Messmatrix} 
\label{sssec:fahrspurerkennung:kalman-filter:zustandsraumbeschreibung:outputmatrix}
Die \glsdesc{lat:outputmatrix} \gls{lat:outputmatrix} bildet den Systemzustand \gls{lat:statevector} auf eine Messung \gls{lat:outputvector} ab. In unserer Implementierung wird  \gls{lat:outputmatrix} passend zu den \gls{x}-Koordinaten der wie in \ref{ssec:fahrspurerkennung:kalman:messung} beschrieben gewonnenen Linienmittelpunkte in jeder Iteration des Kalmanfilters neu berechnet. Aus \ref{eq:polylanestate} ergibt sich:
\begin{equation}
\begin{split}
\gls{lat:outputvector} & =
\begin{pmatrix}
\gls{y}^{\gls{lat:LinienKOS}}_1 \\
\gls{y}^{\gls{lat:LinienKOS}}_2 \\
\vdots \\
\gls{y}^{\gls{lat:LinienKOS}}_{\scl{n}}
\end{pmatrix}
=
\begin{pmatrix}
\gls{lat:lateraloffset} +
\gls{gre:yawangle} \cdot \gls{x}^{\gls{lat:LinienKOS}}_{1} +
\frac{1}{2} \cdot \gls{lat:curvature} \cdot (\gls{x}^{\gls{lat:LinienKOS}}_{1})^2 +
\frac{1}{6} \cdot \gls{lat:curvaturechange} \cdot (\gls{x}^{\gls{lat:LinienKOS}}_{1})^3  \\
\gls{lat:lateraloffset} +
\gls{gre:yawangle} \cdot \gls{x}^{\gls{lat:LinienKOS}}_{2} +
\frac{1}{2} \cdot \gls{lat:curvature} \cdot (\gls{x}^{\gls{lat:LinienKOS}}_{2})^2 +
\frac{1}{6} \cdot \gls{lat:curvaturechange} \cdot (\gls{x}^{\gls{lat:LinienKOS}}_{2})^3  \\
\vdots \\
\gls{lat:lateraloffset} +
\gls{gre:yawangle} \cdot \gls{x}^{\gls{lat:LinienKOS}}_{\scl{n}} +
\frac{1}{2} \cdot \gls{lat:curvature} \cdot (\gls{x}^{\gls{lat:LinienKOS}}_{\scl{n}})^2 +
\frac{1}{6} \cdot \gls{lat:curvaturechange} \cdot 
(\gls{x}^{\gls{lat:LinienKOS}}_{\scl{n}})^3  
\end{pmatrix} \\
& =
\begin{pmatrix}
1 & \gls{x}^{\gls{lat:LinienKOS}}_{1} & \frac{1}{2} \cdot (\gls{x}^{\gls{lat:LinienKOS}}_{1})^2 &
\frac{1}{6} \cdot (\gls{x}^{\gls{lat:LinienKOS}}_{1})^3  \\
1 & \gls{x}^{\gls{lat:LinienKOS}}_{2} & \frac{1}{2} \cdot (\gls{x}^{\gls{lat:LinienKOS}}_{2})^2 &
\frac{1}{6} \cdot (\gls{x}^{\gls{lat:LinienKOS}}_{2})^3  \\
\vdots & \vdots & \vdots & \vdots \\
1 & \gls{x}^{\gls{lat:LinienKOS}}_{\scl{n}} & 
\frac{1}{2} \cdot (\gls{x}^{\gls{lat:LinienKOS}}_{\scl{n}})^2 &
\frac{1}{6} \cdot (\gls{x}^{\gls{lat:LinienKOS}}_{\scl{n}})^3
\end{pmatrix}
\cdot
\begin{pmatrix}
\gls{lat:lateraloffset} \\
\gls{gre:yawangle} \\
\gls{lat:curvature} \\
\gls{lat:curvaturechange} \\
\end{pmatrix}
\end{split}
\end{equation} 

\subsection{Kovarianzmatritzen}
Wie in \autocite{petersfalkoFPGAbasierteBildverarbeitungspipelineZur2009} und \autocite{risackRobustLaneRecognition} werden die Kovarianzmatrix des System-/Prozessrauschens \mtx{Q} und die Kovarianzmatrix des Messrauschens \mtx{R} als konstante Diagonalmatritzen gesetzt. Auf die Prädiktion der Kovarianzmatrix \mtx{P} wird somit verzichtet.

\subsection{konkrete Implementierung des Kalman-Filters}
Ist der \glsdesc{lat:statevector} \gls{lat:statevector} einmal wie in ~\ref{sssec:fahrspurerkennung:kalman:fahrspurmodell:initialisierung} beschrieben initialisiert, können die Gleichungen des Kalmanfilters bei Eintreffen eines neuen Bildes wie folgt berechnet werden:
\begin{enumerate}
\item Bildung der \glsdesc{lat:systemmatrix} \gls{lat:systemmatrix} mittels der seit dem letzten Bild gefahrenen Distanz \scl{\Delta\gls{x}}
\item Prädiktion des \glsdesc{lat:statevector} \gls{lat:statevector}, d.h. der Lage der Fahrspurmarkierungen im aktuellen Bild anhand von \eqref{eq:kalmanprediction}
\item Messung der Lage der Fahrspur wie in \ref{ssec:fahrspurerkennung:kalman:messung}
erläutert
\item Bildung der \glsdesc{lat:outputmatrix} \gls{lat:outputmatrix} passend zur Messung wie in \ref{sssec:fahrspurerkennung:kalman-filter:zustandsraumbeschreibung:outputmatrix} beschrieben
\item Korrektur des \glsdesc{lat:statevector}s \gls{lat:statevector} unter Nutzung von \eqref{eq:kalmancorrection}
\end{enumerate}




