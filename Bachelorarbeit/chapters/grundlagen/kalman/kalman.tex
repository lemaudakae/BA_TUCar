\section{Kalman-Filter}
Das Kalman-Filter ist ein bereits 1960 entwickeltes Verfahren zur Zustandsschätzung von zeitdiskreten, linearen Systemen \autocite{kalmanNewApproachLinear1960}. Durch seinen Iterativen Aufbau, welcher alle vorherigen Zustände mit wenig Rechenaufwand berücksichtigen kann ist es besonders interessant für Echtzeitanwendungen. Die Fähigkeit redundante Messungen zu vereinigen macht es sehr attraktiv in vielerlei Hinsicht. Die folgenden Grundlagen stellen eine Kurzfassung von \autocite{marchthalerKalmanFilterEinfuehrungZustandsschaetzung2017} dar.

\subsection{Zustandsraumdarstellung}
Um ein Kalman-Filter nutzen zu können wird für den betrachteten Prozess ein Modell im Zustandsraum benötigt. In \eqref{eq:statespacerep} ist die allgemeine Zustandsraumbeschreibung für zeitinvariante, lineare Systeme aufgeführt. Da das Kalman-Filter für die Verwendung mit zeitdiskreten Systemen konzipiert wurde und im digitalen Bereich Messwerte lediglich abgetastet vorliegen, muss dieses kontinuierliche Modell später diskretisiert werden \eqref{eq:statespacerepdisc}.
\begin{subequations}
\label{eq:statespacerep}
\begin{equation}
\dot{\gls{lat:statevector}}(\gls{lat:time}) = 
\gls{lat:systemmatrix} \cdot \gls{lat:statevector}(\gls{lat:time}) +
\gls{lat:inputmatrix} \cdot \gls{lat:inputvector}(\gls{lat:time}) +
\gls{lat:processnoisematrix} \cdot \gls{lat:processnoisevector}(\gls{lat:time})
\end{equation}
\begin{equation}
\gls{lat:outputvector} = 
\gls{lat:outputmatrix} \cdot \gls{lat:statevector}(\gls{lat:time}) +
\gls{lat:transmissionmatrix} \cdot \gls{lat:inputvector}(\gls{lat:time}) +
\gls{lat:measnoisevector}(\gls{lat:time})
\end{equation}  
\end{subequations}
\begin{subequations}
\label{eq:statespacerepdisc}
\begin{equation}
\gls{lat:statevector}(\gls{lat:iter}+1) = 
\gls{lat:systemmatrix}_{\gls{idz:discrete}} \cdot \gls{lat:statevector}(\gls{lat:iter}) +
\gls{lat:inputmatrix}_{\gls{idz:discrete}} \cdot \gls{lat:inputvector}(\gls{lat:iter}) +
\gls{lat:processnoisematrix}_{\gls{idz:discrete}} \cdot \gls{lat:processnoisevector}(\gls{lat:iter})
\end{equation}
\begin{equation}
\gls{lat:outputvector} = 
\gls{lat:outputmatrix}_{\gls{idz:discrete}} \cdot \gls{lat:statevector}(\gls{lat:iter}) + 
\gls{lat:transmissionmatrix}_{\gls{idz:discrete}} \cdot \gls{lat:inputvector}(\gls{lat:iter}) +
\gls{lat:measnoisevector}_{\gls{idz:discrete}}(\gls{lat:iter})
\end{equation}  
\end{subequations}

\subsection{Filtergleichungen}
Sobald die Zustandsraumbeschreibung aufgestellt ist, können die folgenden Filtergleichungen angewandt werden:

\subsubsection{Korrektur}
\begin{subequations}
\label{eq:kalmancorrection}
\begin{equation}
\hat{\gls{lat:outputvector}}(\gls{lat:iter}) =
\gls{lat:outputmatrix} \cdot \hat{\gls{lat:statevector}}(\gls{lat:iter}) +
\gls{lat:transmissionmatrix} \cdot \gls{lat:inputvector}(\gls{lat:iter})
\end{equation}
\begin{equation}
\gls{lat:innovation}(\gls{lat:iter}) =
\gls{lat:outputvector}(\gls{lat:iter}) -
\hat{\gls{lat:outputvector}}(\gls{lat:iter})
\end{equation}
\begin{equation}
\gls{lat:kalmangain}(\gls{lat:iter}) =
\hat{\gls{lat:covariancematrix}}(\gls{lat:iter}) \cdot \gls{lat:outputmatrix}^T
\cdot (  \gls{lat:outputmatrix} \cdot \hat{\gls{lat:covariancematrix}}(\gls{lat:iter}) \cdot 
\gls{lat:outputmatrix}^T + \gls{lat:measnoisevariancematrix}(\gls{lat:iter} ))^{-1}
\end{equation}
\begin{equation}
\tilde{\gls{lat:statevector}}(\gls{lat:iter}) =
\hat{\gls{lat:statevector}}(\gls{lat:iter}) + 
\gls{lat:kalmangain}(\gls{lat:iter}) \cdot \gls{lat:innovation}(\gls{lat:iter})
\end{equation}
\begin{equation}
\tilde{\gls{lat:covariancematrix}}(\gls{lat:iter}) =
( \gls{lat:unitmatrix} - \gls{lat:kalmangain}(\gls{lat:iter}) \cdot \gls{lat:outputmatrix} )
\cdot \tilde{\gls{lat:covariancematrix}}(\gls{lat:iter})
\end{equation}
\end{subequations}

\subsubsection{Prädikation}
\begin{subequations}
\label{eq:kalmanprediction}
\begin{equation}
\hat{\gls{lat:statevector}}(\gls{lat:iter}+1) =
\gls{lat:systemmatrix}_{\gls{idz:discrete}} \cdot 
\tilde{\gls{lat:statevector}}(\gls{lat:iter}) +
\gls{lat:inputmatrix}_{\gls{idz:discrete}} \cdot \gls{lat:inputvector}(\gls{lat:iter})
\end{equation}
\begin{equation}
\hat{\gls{lat:covariancematrix}}(\gls{lat:iter}+1) =
\gls{lat:systemmatrix}_{\gls{idz:discrete}} \cdot
\tilde{\gls{lat:covariancematrix}}(\gls{lat:iter}) \cdot
\gls{lat:systemmatrix}_{\gls{idz:discrete}}^T +
\gls{lat:processnoisematrix}_{\gls{idz:discrete}} \cdot
\gls{lat:processnoisevariancematrix}(\gls{lat:iter}) \cdot
\gls{lat:processnoisematrix}_{\gls{idz:discrete}}^T
\end{equation}
\end{subequations}